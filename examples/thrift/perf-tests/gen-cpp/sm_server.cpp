// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FDSP_DataPathReq.h"
#include "FDSP_DataPathResp.h"  // As an example

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>

#include <stdexcept>
#include <sstream>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;


using namespace  ::FDS_ProtocolInterface;

class FDSP_DataPathReqHandler : virtual public FDSP_DataPathReqIf {
 public:
  boost::shared_ptr<TProtocol> protocol_;
  boost::shared_ptr<FDSP_DataPathRespClient> client;


  FDSP_DataPathReqHandler() {
    // Your initialization goes here
  }

  void GetObject(const FDSP_MsgHdrType& fdsp_msg, const FDSP_GetObjType& get_obj_req) {
    // Your implementation goes here
    printf("GetObject\n");
  }

  void PutObject(const FDSP_MsgHdrType& fdsp_msg, const FDSP_PutObjType& put_obj_resp) {
    // Your implementation goes here
    printf("PutObject\n");

//  FDS_ProtocolInterface::FDSP_MsgHdrType fdsp_msg_hdr ;
//  FDS_ProtocolInterface::FDSP_PutObjType put_obj_rsp ;
    // send reply back
    if (client) {
      printf("Responding to PutObject request \n");
      client->PutObjectResp(fdsp_msg, put_obj_resp);
    }

  }

  void DeleteObject(const FDSP_MsgHdrType& fdsp_msg, const FDSP_DeleteObjType& del_obj_req) {
    // Your implementation goes here
    printf("DeleteObject\n");
  }

  void AssociateRespCallback(const std::string& src_node_name) {
    // Your implementation goes here
    printf("AssociateRespCallback\n");
  }

  void setClient(boost::shared_ptr<TTransport> trans)
  {
    printf("DataPathReqHandler: set FDSP_DataPathRespClient\n");
    protocol_.reset(new TBinaryProtocol(trans));
    client.reset(new FDSP_DataPathRespClient(protocol_));
  }

};


class FdsDataPathReqProcessorFactory: public TProcessorFactory {
public:
  FdsDataPathReqProcessorFactory(const boost::shared_ptr<FDSP_DataPathReqIfFactory> &handlerFactory)
    : handler_factory(handlerFactory) {}

  boost::shared_ptr<TProcessor> getProcessor(const TConnectionInfo& connInfo)
  {
    FDSP_DataPathReqHandler* ptr = dynamic_cast<FDSP_DataPathReqHandler*>(handler_factory->getHandler(connInfo));
    ptr->setClient(connInfo.transport);

    ReleaseHandler<FDSP_DataPathReqIfFactory> cleanup(handler_factory);
    boost::shared_ptr<FDSP_DataPathReqIf> handler(handler_factory->getHandler(connInfo), cleanup);
    boost::shared_ptr<TProcessor> processor(new FDSP_DataPathReqProcessor(handler));
    return processor;
  }

protected:
  boost::shared_ptr<FDSP_DataPathReqIfFactory> handler_factory;
};



int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  // will have to find out  more on the singleton  factory 
  boost::shared_ptr<FDSP_DataPathReqHandler> handler(new FDSP_DataPathReqHandler());
  boost::shared_ptr<FDSP_DataPathReqIfSingletonFactory> handlerFactory(new FDSP_DataPathReqIfSingletonFactory(handler));
  boost::shared_ptr<TProcessorFactory> processorFactory(new FdsDataPathReqProcessorFactory(handlerFactory));


 // threaded server 
  boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(2);
  boost::shared_ptr<PosixThreadFactory> threadFactory =
    boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();

  TThreadPoolServer server(processorFactory,
                           serverTransport,
                           transportFactory,
                           protocolFactory,
                           threadManager);


  server.serve();

  return 0;
}

