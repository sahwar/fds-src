/**
 * Copyright (c) 2015 Formation Data Systems.  All rights reserved.
 */

package com.formationds.client.v08.model;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Objects;

/**
 * Base class for external model resources.  Each resource has a system-generated ID as well as
 * a natural key / name.
 * <p/>
 * In most cases the ID is generated by the server, so when creating new resources the id will be null.
 * <p/>
 * Equals method implementation is based on the ID equality if the id is set.  However, the Comparable
 * implementation is based on name comparison.  That is, they are inconsistent and thus an AbstractResource
 * is not a good candidate for use as a key in Collections.  You can use the name or id comparator with ordered
 * sets.
 * @param <I>
 */
public abstract class AbstractResource<I extends Comparable<I>> implements Comparable<AbstractResource> {

    /**
     * @return a resource name-based comparator
     */
    public static Comparator<AbstractResource> nameCompare() { return ( o1, o2 ) -> o1.name.compareTo( o2.name );}

    /**
     *
     * @return a resource id-based comparator
     */
    public static Comparator<AbstractResource> idCompare() { return ( o1, o2 ) -> o1.uid.compareTo( o2.uid );}

    private I      uid;
    private final String name;

    /**
     * Create a resource with the specified unique name
     *
     * @param name the resource name
     */
    public AbstractResource( String name ) {
        this.uid = null;
        this.name = name;
    }

    /**
     * Create a resource with the specified unique identifier and name
     * @param uid the unique identifier
     * @param name the resource name
     */
    public AbstractResource( I uid, String name ) {
        this.uid = uid;
        this.name = name;
    }

    /**
     * Create a resource with the specified unique identifier and a name constructed from the
     * set of name components, delimited by a '.' character.
     *
     * @param uid the unique identifier
     * @param names the components that make a unique resource name/key
     */
    public AbstractResource( I uid, String... names ) {
        this( uid, '.', names );
    }

    /**
     *
     * @param uid the unique identifier
     * @param delim a delimiter for the name component
     * @param names the components that make a unique resource name/key
     */
    public AbstractResource( I uid, char delim, String... names ) {
        this.uid = uid;

        if ( names.length == 1 ) {
            this.name = names[0];
        } else {
            StringBuilder sb = new StringBuilder();
            Iterator<String> niter = Arrays.asList( names ).iterator();
            while ( niter.hasNext() ) {
                sb.append( niter.next() );
                if ( niter.hasNext() )
                    sb.append( delim );
            }
            this.name = sb.toString();
        }
    }

    /**
     * Set the resource ID.  This is package-private as it is intended for use only by internal framework.
     *
     * @param id the ID
     */
    void setId(I id) {
        if (this.uid != null) {
            throw new IllegalStateException( "ID is already set." );
        }
        this.uid = id;
    }

    /**
     *
     * @return the unique identifier for this resource, which may be null indicating the resource has not yet
     * been saved or "attached" to a persisted version of the resource.
     */
    public I getId() { return uid; }

    /**
     *
     * @return the unique resource name
     */
    public String getName() { return name; }

    @Override
    public int compareTo( AbstractResource o ) {
        return name.compareTo( o.getName() );
    }

    /**
     * @param o the resource name to compare
     * @return  true if the name of this resource equals the name of that resource
     */
    public boolean nameEquals(AbstractResource o) {
        if ( this == o ) { return true; }
        return Objects.equals( name, o.name );
    }

    @Override
    public boolean equals( Object o ) {
        if ( this == o ) { return true; }
        if ( !(o instanceof AbstractResource) ) { return false; }
        final AbstractResource<?> that = (AbstractResource<?>) o;

        // TODO: not 100% sure if this is correct by the strict definition of Object equality and hash codes.
        if ( uid == null || that.uid == null ) {
            return Objects.equals( name, that.name );
        } else {
            return Objects.equals( uid, that.uid ) &&
                   Objects.equals( name, that.name );
        }
    }

    @Override
    public int hashCode() {
        return Objects.hash( uid, name );
    }
}
