#!/bin/bash
########################################################################
#  fds control script. to start stop services on a dev machine
#  usage : fds -h
#  symlink this script to ~/bin & add it to your PATH for convenience
########################################################################
# setup correct dirs
SOURCE="${BASH_SOURCE[0]}"
# resolve $SOURCE until the file is no longer a symlink
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done

# If run from source dir
TOOLSDIR="$(cd -P "$( dirname "${SOURCE}" )" && pwd )"
SOURCEDIR="$( cd ${TOOLSDIR}/.. && pwd)"
CONFIG_ETC=${SOURCEDIR}/config/etc

BUILDMODE="debug"
RELEASEMODEFILE="${SOURCEDIR}/Build/.build-mode-release.chk"
if [[ -e $RELEASEMODEFILE ]]; then
    BUILDMODE="release"
fi

BINDIR="${SOURCEDIR}/Build/linux-x86_64.${BUILDMODE}/bin"
TESTDIR="${SOURCEDIR}/Build/linux-x86_64.${BUILDMODE}/tests"
KODIR="${SOURCEDIR}/fds_client/blk_dev"
FDSROOT=/fds
FDSTEST_ROOT=/fds-test

# else run from install dir
run_from_install_dir=0

source ${TOOLSDIR}/loghelper.sh
init_loghelper /tmp/fds_tool.${UID}.log
########################################################################

REDIS_ARG=

# Variables
applist="pm om dm sm am xdi"
declare -A proc
proc["am"]="bare_am"
proc["xdi"]="java"
proc["om"]="java"

declare -A apps
apps["om"]="orchMgr"
apps["am"]="AMAgent"
apps["xdi"]="AMAgent"
apps["sm"]="StorMgr"
apps["dm"]="DataMgr"
apps["pm"]="platformd"

function usage() {
    log "$(yellow usage: $(basename $0) [cmd] [app] [options])"
    log " cmd : "
    log "   - $(yellow start)     : start the app "
    log "   - $(yellow stop)      : stop  the app "
    log "   - $(yellow restart)   : stop & start  the app "
    log "   - $(yellow status)    : print status of the apps"
    log "   - $(yellow clogs)     : remove the logs"
    log "   - $(yellow clean)     : remove the data"
    log "   - $(yellow cleanstart): stop+clean+start all"
    log "   - $(yellow tail)      : tail the application log file"
    log "   - $(yellow error)     : show errors/warn/critical from application log"
    log "   - $(red    gdb)       : gdb attach app"
    log "   - $(yellow release)   : switch to $(green release) build"
    log "   - $(yellow debug)     : switch to $(red debug) build"
    log " options :"
    log "   : $(yellow --fds-root/-f) rootdir"
    log " app : om/pm/sm/am/dm/all"
    printBuildMode
    exit 0
}

function printBuildMode() {
    case "${BUILDMODE}" in
        release)
            logwarn "$(blue current build mode) : $(green ${BUILDMODE})"
            ;;
        debug)
            logwarn "$(blue current build mode) : $(red ${BUILDMODE})"
            ;;
        *)
            logerror "unknown build mode : ${BUILDMODE}"
            ;;
    esac
}

function setBuildMode() {
    local mode="$1"

    if [[ $mode == "release" ]]; then
        touch $RELEASEMODEFILE
    elif [[ $mode == "debug" ]]; then
        rm -f $RELEASEMODEFILE
    else
        logerror "unknown build mode : $mode"
        return 1
    fi
    BUILDMODE=$mode
    printBuildMode
    return 0
}

function setupFdsDirs() {
    loginfo "setting up: ${FDSROOT} "
    if [[ ! -d ${FDSROOT} ]] ; then mkdir -p ${FDSROOT} ; fi

    loginfo "setting up: ${FDSROOT}/etc "
    if [[ $(readlink ${FDSROOT}/etc) != "${CONFIG_ETC}" ]] ; then
        cp -rf ${CONFIG_ETC} ${FDSROOT}
    fi
    # setup fds test dir
    loginfo "setting up: ${FDSTEST_ROOT} "
    if [[ ! -d ${FDSTEST_ROOT} ]] ; then mkdir -p ${FDSTEST_ROOT} ; fi

    loginfo "setting up: ${FDSTEST_ROOT}/etc "
    if [[ $(readlink ${FDSTEST_ROOT}/etc) != "${CONFIG_ETC}" ]] ; then
        cp -rf ${CONFIG_ETC} ${FDSTEST_ROOT}
    fi
}

function activate() {
    local actapps
    if [[ -z $(getAppPid am) ]]; then actapps="${actapps}am,"; fi
    if [[ -z $(getAppPid dm) ]]; then actapps="${actapps}dm,"; fi
    if [[ -z $(getAppPid sm) ]]; then actapps="${actapps}sm,"; fi
    if [[ -n $actapps ]]; then
        # Bao: wait for platformd before activate
        sleep 5

        logwarn "asking OM to accept all discovered nodes..."
        (cd ${BINDIR}; ./fdscli --fds-root ${FDSROOT} --activate-nodes abc -k 1 -e "$actapps" > cli.out) 2>/dev/null
        loginfo "$(boldblue fdscli) : console out : ${BINDIR}/cli.out"
    fi
}

function startApp() {
    local appname=$1
    local justapps="${applist}"

    setupFdsDirs

    if [[ $appname == "all" ]]; then
        justapps="pm om"
    fi

    # start redis if needed
    case "$appname" in
        om|pm|all|redis)
            ${TOOLSDIR}/redis.sh start 1 $REDIS_ARG
            ;;
    esac

    # start influxdb if needed
    case "$appname" in
        om|all|influx*)
            sudo service influxdb status 2>&1 >> /dev/null
            if [ $? != 0 ]; then
                sudo service influxdb start 2>&1 >> /dev/null
                if [ $? != 0 ]; then
                    logwarn "Failed to start InfluxDB"
                fi
            fi
            ;;
    esac

    for name in $justapps ; do
        if [[ $appname == ${name} ]] || [[ $appname == "all" ]] ; then
            pid=$(getAppPid $name)
            if [[ -z $pid ]] ; then
                loginfo "$(boldblue ${name}) $(yellow starting ..)"
                (cd ${BINDIR}; ./${apps[$name]} --fds-root ${FDSROOT} > ${name}.out 2>&1 &)
                loginfo "$(boldblue ${name}) : console out : ${BINDIR}/${name}.out"
                sleep 2s
		if ! (waitForApp $name) ; then
                    logerror "oops!! something wrong.. [$(boldblue $name)] is $(red not) showing up."
                    loginfo "here is the log file: ${BINDIR}/${name}.out"
                    tail ${BINDIR}/${name}.out
                fi
                sleep 1s
            else
                logwarn "$(boldblue ${name}) ... already running"
            fi
        fi
    done

    case "$appname" in
        om|all)
            activate
            ;;
    esac
}

function stopApp() {
    local appname=$1

    if [[ $appname == "redis" ]] ; then
        ${TOOLSDIR}/redis.sh stop 1 $REDIS_ARG
    fi

    case "$appname" in 
        om|all|influx*)
            sudo service influxdb status 2>&1 >> /dev/null
            if [ $? == 0 ]; then
                sudo service influxdb stop 2>&1 >> /dev/null
                if [ $? != 0 ]; then
                    logwarn "Failed to stop InfluxDB"
                fi
            fi
            ;;
    esac

    for name in $applist ; do
        if [[ $appname == ${name} ]] || [[ $appname == "all" ]] ; then
            pid="$(getAppPid $name)"
            if [[ -z $pid ]] ; then
                loginfo "$(boldblue ${name}) : Not running"
            else
                logwarn "$(yellow stopping ${name}..)"
                for procid in $pid; do
                    kill -9 ${procid}
                done
            fi
        fi
    done

    # Not stopping redis for now
}

function statusApp() {
#    echo "====================================================================================="
#    echo "=    This feature is deprecated, please use fdsadmin --status (or --process-status) ="
#    echo "====================================================================================="

    # the header
    echo "$(yellow app: $(ps u --pid 1000000 | awk '{for(i=1;i<12;i++) printf("\t%s",$i) }'))"

    local appname=$1

    for name in $applist ; do
        if [[ $appname == ${name} ]] || [[ $appname == "all" ]] ; then
            pid="$(getAppPid $name)"
            if [[ -z $pid ]] ; then
                echo "$(boldblue ${name}) : $(yellow Not running)"
            else
                local num=1
                for procid in $pid ; do
                    if [[ $num == 1 ]]; then
                        echo "$(boldblue ${name}) : $(green $(ps u --pid $procid | tail -n1 | awk '{for(i=1;i<13;i++) printf("\t%s",$i) }'))"
                    else
                        echo "$(yellow ${name}) : $(red $(ps u --pid $procid | tail -n1 | awk '{for(i=1;i<13;i++) printf("\t%s",$i) }'))"
                    fi
                    num=$((num+1))
                done
            fi
        fi
    done

    # redis status
    if [[ $appname == "all" ]] || [[ $appname == "redis" ]] ; then
        ${TOOLSDIR}/redis.sh status 1 $REDIS_ARG
    fi

    case "$appname" in 
        om|all|influx*)
            sudo service influxdb status 2>&1 >> /dev/null
            if [ $? == 0 ]; then
                echo "$(boldblue influxdb) : $(green RUNNING)"
            else 
                echo "$(boldblue influxdb) : $(yellow Not running)"
            fi
            ;;
    esac
}

function getAppPid() {
    local name=$1
    local pid

    if [[ $name == "om" ]]; then
        pid="$(pgrep -f com.formationds.om.Main)"
    elif [[ $name == "am" ]]; then
        pid="$(pgrep bare_am)"
    elif [[  $name == "xdi"  ]]; then
        pid="$(pgrep -f com.formationds.am.Main)"
    else
        pid="$(pgrep ${apps[$name]})"
    fi
    echo -n $pid
}

function waitForAll() {
    local lpid=""
    local maxcount=20
    local count=0
    echo -n "... waiting for system to come up: "
    for name in $applist ; do
        lpid=""
        while [[ -z $lpid ]] && [[ $count -lt $maxcount ]] ; do
            echo -n "."
            lpid=$(getAppPid $name)
            if [[ -z $lpid ]]; then
                (( count++ ))
                sleep 1s ;
            fi
        done
    done
    echo
}

function waitForApp() {
    local name=$1
    local lpid=""
    local maxcount=20
    local waittime=1
    if [[ $# -ge 2 ]] ; then
        maxcount=$2
    fi

    if [[ $# -ge 3 ]] ; then
       waittime=$3
    fi

    local count=0
    echo -n "... waiting for [$(boldblue $name)] to come up: "
    lpid=""
    while [[ -z $lpid ]] && [[ $count -lt $maxcount ]] ; do
        echo -n "."
        lpid=$(getAppPid $name)
        if [[ -z $lpid ]]; then
            (( count++ ))
            sleep ${waittime}s ;
        fi
    done
    echo

    if [[ -z $lpid ]]; then
        return 1
    else
        return 0
    fi
}

function attachgdb() {
    local app=$1
    case "${app}" in
        om|am|dm|sm|pm|redis) ;;
    *)
        logerror "can attach gdb to only [om|am|dm|sm|pm|redis]"
        return
        ;;
    esac

    if (waitForApp $app 2000 0.1); then
        sudo gdb -p $(getAppPid $app)
    else
        logerror "could not attach to [$(blue $app)]"
    fi
}

function taillog() {
    local app=$1
    local logfiles
    case "${app}" in
        om|am|dm|sm|pm)
            ls -1 ${FDSROOT}/var/logs/${app}.log*.log
            for n in $(seq 0 20); do
                logfiles="$logfiles ${FDSROOT}/var/logs/${app}.log_${n}.log"
            done
            tail -qF ${logfiles} 2>/dev/null
            ;;
        redis)
            tail -F /fds/logs/redis/*.log
            ;;
        *)
            logerror "can tail logs of only om|am|dm|sm|pm|redis"
            ;;
    esac
}

function showerrors() {
    local apps="$@"
    if [[ $1 == 'all' ]]; then
        apps="am om dm sm pm xdi"
    fi
    for app in ${apps}; do
        loginfo $(yellow "showing errors/warn/critical log data for : ") $(blue $app)
        case "${app}" in
            om|am|dm|sm)
                grep -iE "\[(warning|error|CRITICAL)\]" ${FDSROOT}/var/logs/${app}.log*.log 2>/dev/null
                ;;
            pm)
                grep -iE "\[(warning|error|CRITICAL)\]" ${FDSROOT}/var/logs/platform.log*.log 2>/dev/null
                ;;
            xdi)
                grep -E " (WARN|ERROR|FATAL) " ${FDSROOT}/var/logs/om-xdi*.log ${FDSROOT}/var/logs/xdi*.log 2>/dev/null
                ;;
            *)
                logerror "can grep logs of only om|am|dm|sm|pm|xdi"
                ;;
        esac
        echo
    done
}


function cleanBinDirs() {
    for node in bin node2 node3 node4; do
        bin_dir=${SOURCEDIR}/Build/linux-x86_64.${BUILDMODE}/${node}
        if [[ -d $bin_dir ]] ; then
            (
                cd ${bin_dir}
                loginfo "cleaning up: $(pwd)"

                rm -rf *.ldb 2>  /dev/null
                rm -rf logs stats 2> /dev/null
                rm -rf *SNode* 2> /dev/null
                rm -rf *ObjRankDB* 2> /dev/null
                rm om.*.log 2> /dev/null
                rm am.*.log 2> /dev/null
                rm sm.*.log 2> /dev/null
                rm -f ocache_stats.dat
                rm -f *.out
                rm -f core*
                rm -f Volume_* 2>/dev/null
            )
        fi
    done
}


function clean() {
    for node in ${FDSROOT} ${FDSROOT}/node1 ${FDSROOT}/node2 ${FDSROOT}/node3 ${FDSROOT}/node4 ; do
        if [[ -d $node ]] ; then
            loginfo "cleaning up: ${node}"
            (
                rm -rf /${node}/hdd/sd?
                rm -rf /${node}/ssd/sd?
                rm -rf /${node}/sys-repo/*
                rm -rf /${node}/user-repo/*
                rm -rf /${node}/dev/*
                rm -rf /${node}/var/stats/*
                rm -rf /${node}/var/db/*
                # redis stuff
                ${TOOLSDIR}/redis.sh clean 1 $REDIS_ARG

                # influxdb
                # TODO: how to clean influx data?
				rm -rf /${node}/var/logs
                #cleanlogs
            ) 2>/dev/null
        fi
    done

	rm -f /dev/shm/0x*

    cleanBinDirs
}

function cleanlogs() {
    (
        rm -f $(find /${FDSROOT}/var/ -type f | grep -v redis)
        rm -f $(find /${FDSROOT}/logs -type f | grep -v redis)
    ) 2>/dev/null
}

function source_lib() {
    export LD_LIBRARY_PATH=${FDSROOT}/lib:/usr/local/lib:/usr/lib/jvm/java-8-oracle/jre/lib/amd64;
    ulimit -c unlimited; ulimit -n 12800;
}

########################################################################
# Main Program
########################################################################

# parse input
# parse out the options & leave the rest is saved
args=( "$@" )
for ((n=0; n<$#; n++ ))
do
    opt=${args[$n]}
    case $opt in
        -f|--fds-root)
            (( n++ ))
            if [[ $n -ge $# ]]; then
                logerror "value expected for fdsroot"
                usage
            fi
            FDSROOT=${args[$n]}
            ;;
        -i|--from-install-dir)
            run_from_install_dir=1
            ;;
        -h|--help)
            usage
            ;;
        release)
            setBuildMode release
            exit 0
            ;;
        debug)
            setBuildMode debug
            exit 0
            ;;
        mode)
            printBuildMode
            exit 0
            ;;
        bindir)
            echo $BINDIR
            exit 0
            ;;
        testdir)
            echo $TESTDIR
            exit 0
            ;;
        *)
            if [[ -z $CMD ]] ; then CMD=$opt
            elif [[ -z $APP ]] ; then APP=$opt
            else
                logerror "unknown option [$opt] "
                usage
            fi
    esac
done

# else run from install dir
if [ $run_from_install_dir -eq 1 ]; then
    SOURCEDIR="$( cd ${TOOLSDIR}/../.. && pwd)"
    CONFIG_ETC=${SOURCEDIR}/etc
    BINDIR=${SOURCEDIR}/bin
    FDSROOT=${SOURCEDIR}
    REDIS_ARG=-i
    source_lib
fi

# check the values
CMD=${CMD:="status"}
APP=${APP:="all"}
FDSROOT=${FDSROOT:=/fds}

#echo "CMD=${CMD} APP=${APP} ROOT=${FDSROOT} SOURCEDIR=${SOURCEDIR} " \
#     "TOOLSDIR=${TOOLSDIR} CONFIG_ETC=${CONFIG_ETC} BINDIR=${BINDIR}"

#echo "args: ${args[@]}"
#exit 0

case "${CMD}" in
    start|stop|restart|status|clean|clogs|cleanstart|startclean|gdb|tail|err*) ;;
    *)
        logerror "unknown cmd [$CMD] "
        usage ;;
esac

case "${APP}" in
    om|am|dm|sm|pm|all|redis) ;;
    *)
        logerror "unknown app [$APP]"
        usage ;;
esac

printBuildMode

case "${CMD}" in
    start) startApp $APP
        [[ $APP == "all" ]] && waitForAll
        statusApp $APP
        ;;
    stop) stopApp  $APP;;
    status) statusApp $APP;;
    clean) clean ;;
    clogs) cleanlogs ;;
    restart)
            stopApp $APP
            startApp $APP
            waitForAll
            statusApp $APP
            ;;
    cleanstart|startclean)
        stopApp "all"
        clean
        startApp "all"
        waitForAll
        statusApp "all"
        ;;
    gdb)
        attachgdb $APP
        ;;
    tail)
        taillog $APP
        ;;
    err*)
        showerrors $APP
        ;;
    *) usage ;;
esac
