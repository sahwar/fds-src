#!/bin/bash
########################################################################
#  fds control script. to start stop services on a dev machine
#  usage : fds -h
#  symlink this script to ~/bin & add it to your PATH for convenience
########################################################################
# setup correct dirs
SOURCE="${BASH_SOURCE[0]}"
# resolve $SOURCE until the file is no longer a symlink
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done

# If run from source dir
TOOLSDIR="$(cd -P "$( dirname "${SOURCE}" )" && pwd )"
SOURCEDIR="$( cd ${TOOLSDIR}/.. && pwd)"
CONFIG_ETC=${SOURCEDIR}/config/etc

BUILDMODE="debug"
RELEASEMODEFILE="${SOURCEDIR}/Build/.build-mode-release.chk"
if [[ -e $RELEASEMODEFILE ]]; then
    BUILDMODE="release"
fi

BINDIR="${SOURCEDIR}/Build/linux-x86_64.${BUILDMODE}/bin"
TESTDIR="${SOURCEDIR}/Build/linux-x86_64.${BUILDMODE}/tests"
KODIR="${SOURCEDIR}/fds_client/blk_dev"
FDSROOT=/fds
FDSTEST_ROOT=/fds-test

# else run from install dir
run_from_install_dir=0

source ${TOOLSDIR}/loghelper.sh
init_loghelper /tmp/fds_tool.${UID}.log
########################################################################

REDIS_ARG=

# Variables
applist="pm om dm sm am xdi"
declare -A proc
proc["am"]="bare_am"
proc["xdi"]="java"
proc["om"]="java"

declare -A apps
apps["om"]="orchMgr"
apps["am"]="bare_am"
apps["xdi"]="am.Main"
apps["sm"]="StorMgr"
apps["dm"]="DataMgr"
apps["pm"]="platformd"

declare -A TESTS
TESTS["restart-full"]="FullRestartMultiNodeTest.ini"
TESTS["restart-simple"]="SimpleRestartMultiNodeTest.ini"
TESTS["restart"]="SimpleRestartTest.ini"
TESTS["smoke"]="BuildSmokeTest_onpr.ini"

function usage() {
    log "$(yellow usage: $(basename $0) [cmd] [app/testname] [options])"
    log " cmd : "
    log "   - $(yellow start)     : start the app "
    log "   - $(yellow stop)      : stop  the app "
    log "   - $(yellow restart)   : stop & start  the app "
    log "   - $(yellow status)    : print status of the apps"
    log "   - $(yellow clogs)     : remove the logs"
    log "   - $(yellow clean)     : remove the data"
    log "   - $(yellow cleanstart): stop+clean+start all"
    log "   - $(yellow test)      : run specific tests"
    log "   - $(yellow tail)      : tail the application log file"
    log "   - $(yellow error)     : show errors/warn/critical from application log"
    log "   - $(red    gdb)       : gdb attach app"
    log "   - $(yellow release)   : switch to $(green release) build"
    log "   - $(yellow debug)     : switch to $(red debug) build"
    log " options :"
    log "   : $(yellow --fds-root/-f) rootdir"
    log " app : om/pm/sm/am/dm/all"
    log " $(yellow testname): name of a test"
    echo -e "${!TESTS[@]}" | tr " " "\n" | sort | sed -e "s/^/    - /g" 
    printBuildMode
    exit 0
}

function printBuildMode() {
    case "${BUILDMODE}" in
        release)
            logwarn "$(blue current build mode) : $(green ${BUILDMODE})"
            ;;
        debug)
            logwarn "$(blue current build mode) : $(red ${BUILDMODE})"
            ;;
        *)
            logerror "unknown build mode : ${BUILDMODE}"
            ;;
    esac
}

function setBuildMode() {
    local mode="$1"

    if [[ $mode == "release" ]]; then
        touch $RELEASEMODEFILE
    elif [[ $mode == "debug" ]]; then
        rm -f $RELEASEMODEFILE
    else
        logerror "unknown build mode : $mode"
        return 1
    fi
    BUILDMODE=$mode
    printBuildMode
    return 0
}

function setupFdsDirs() {
    loginfo "setting up: ${FDSROOT} "
    if [[ ! -d ${FDSROOT} ]] ; then mkdir -p ${FDSROOT} ; fi

    loginfo "setting up: ${FDSROOT}/etc "
    if [[ $(readlink ${FDSROOT}/etc) != "${CONFIG_ETC}" ]] ; then
        cp -rf ${CONFIG_ETC} ${FDSROOT}
    fi
    # setup fds test dir
    loginfo "setting up: ${FDSTEST_ROOT} "
    if [[ ! -d ${FDSTEST_ROOT} ]] ; then mkdir -p ${FDSTEST_ROOT} ; fi

    loginfo "setting up: ${FDSTEST_ROOT}/etc "
    if [[ $(readlink ${FDSTEST_ROOT}/etc) != "${CONFIG_ETC}" ]] ; then
        cp -rf ${CONFIG_ETC} ${FDSTEST_ROOT}
    fi

    cd ${SOURCEDIR}
    if [ ${UID} -ne 0 ]; then
        sudo ./dev_make_install.sh
    else
        ./dev_make_install.sh
    fi
    cd - > /dev/null
}

function activate() {
    local actapps
    if [[ -z $(getAppPid am) ]]; then actapps="${actapps}am,"; fi
    if [[ -z $(getAppPid dm) ]]; then actapps="${actapps}dm,"; fi
    if [[ -z $(getAppPid sm) ]]; then actapps="${actapps}sm,"; fi
    if [[ -n $actapps ]]; then
        # Bao: wait for platformd before activate
        sleep 14

        logwarn "asking OM to accept all discovered nodes..."
	(cd ${TOOLSDIR}; ./fdsconsole.py domain activateServices local dm,sm,am> cli.out) 2>/dev/null
    fi
}

function startApp() {
    local appname=$1
    local justapps="${applist}"

    setupFdsDirs

    if [[ $appname == "all" ]]; then
        justapps="pm om"
    fi

    # start redis if needed
    case "$appname" in
        om|pm|all|redis)
            ${TOOLSDIR}/redis.sh start 1 $REDIS_ARG
            ;;
    esac

    # start influxdb if needed
    case "$appname" in
        om|all|influx*)
            startInfluxDB
            ;;
    esac

    for name in $justapps ; do
        if [[ $appname == ${name} ]] || [[ $appname == "all" ]] ; then
            pid=$(getAppPid $name)
            if [[ -z $pid ]] ; then
                case $name in
                    sm|dm|am)
                        params="--foreground --fds.pm.platform_uuid=$(echo 'keys node* '| redis-cli | cut -d: -f2)"
                        ;;
                    *)
                        params=""
                        ;;
                esac

                loginfo "$(boldblue ${name}) $(yellow starting ..)"
                echo $params
                (cd ${BINDIR}; ./${apps[$name]} --fds-root=${FDSROOT} $params > ${name}.out 2>&1 &)
                loginfo "$(boldblue ${name}) : console out : ${BINDIR}/${name}.out"

		if ! (waitForApp $name) ; then
                    logerror "oops!! something wrong.. [$(boldblue $name)] is $(red not) showing up."
                    loginfo "here is the log file: ${BINDIR}/${name}.out"
                    tail ${BINDIR}/${name}.out
                fi

            else
                logwarn "$(boldblue ${name}) ... already running"
            fi
        fi
    done

    case "$appname" in
        om|all)
             activate
            ;;
    esac
}

function stopApp() {
    local appname=$1

    if [[ $appname == "redis" ]] ; then
        ${TOOLSDIR}/redis.sh stop 1 $REDIS_ARG
    fi

    case "$appname" in 
        om|all|influx*)
            if [ "$CMD" != "clean" ]; then
                stopInfluxDB
            fi
            ;;
    esac

    for name in $applist ; do
        if [[ $appname == ${name} ]] || [[ $appname == "all" ]] ; then
            pid="$(getAppPid $name)"
            if [[ -z $pid ]] ; then
                loginfo "$(boldblue ${name}) : Not running"
            else
                logwarn "$(yellow stopping ${name}..)"
                for procid in $pid; do
                    kill -9 ${procid}
                done
            fi
        fi
    done

    # Not stopping redis for now
}

function startInfluxDB() {
    local ret=0
    sudo service influxdb status 2>&1 >> /dev/null
    if [ $? != 0 ]; then
        sudo service influxdb start 2>&1 >> /dev/null
        ret=$?
        if [ $ret != 0 ]; then
            logwarn "Failed to start InfluxDB"
        fi
    fi
    return $ret
}

function stopInfluxDB() {
    local ret=0
    sudo service influxdb status 2>&1 >> /dev/null
    if [ $? == 0 ]; then
        sudo service influxdb stop 2>&1 >> /dev/null
        ret=$?
        if [ $ret != 0 ]; then
            logwarn "Failed to stop InfluxDB"
        fi
    fi
    return $ret;
}

function cleanInfluxDB() {

    ## first check if influx is running
    sudo service influxdb status 2>&1 >> /dev/null
    local isRunning=$?

    ## if it is not running, start it.
    if [ $isRunning != 0 ]; then
        loginfo "Starting InfluxDB for clean"
        startInfluxDB
        sleep 5
    fi

    loginfo "cleaning up InfluxDB databases"
    for db in om-eventdb om-metricdb; do
        local out=$(curl -s --write-out ":%{http_code}" -X DELETE "http://localhost:8086/db/$db?u=root&p=root")
        if [ $? != 0 ]; then
            logwarn InfluxDB Request failed: $out
        fi
        local msg=$(echo $out | cut -d : -f 1)
        local httpCode=$(echo $out | cut -d : -f 2)
        if [[ "$httpCode" -lt 200 || "$httpCode" -ge 300 ]]; then
            # influx reported an unsuccessful error code.  Print the message output from the response.
            # we don't currently distinguish between errors and things like redirects.
            loginfo "InfluxDB [HTTP $httpCode]: $msg"
        fi
    done

    ## if influx was NOT running originally, stop it again.
    if [ $isRunning != 0 ]; then
        loginfo "Stopping InfluxDB"
        stopInfluxDB
    fi
}

function statusApp() {
#    echo "====================================================================================="
#    echo "=    This feature is deprecated, please use fdsadmin --status (or --process-status) ="
#    echo "====================================================================================="

    # the header
    echo "$(yellow app: $(ps u --pid 1000000 | awk '{for(i=1;i<12;i++) printf("\t%s",$i) }'))"

    local appname=$1

    for name in $applist ; do
        if [[ $appname == ${name} ]] || [[ $appname == "all" ]] ; then
            pid="$(getAppPid $name zombie)"
            if [[ -z $pid ]] ; then
                echo "$(boldblue ${name}) : $(yellow Not running)"
            else
                local num=1
                for procid in $pid ; do
                    if [[ "Z" == $(ps -o s= -p $procid) ]]; then
                        echo "$(yellow ${name}) : $(boldred $(ps u --pid $procid | tail -n1 | awk '{for(i=1;i<13;i++) printf("\t%s",$i) }'))"
                        num=$((num-1))
                    else
                        if [[ $num == 1 ]]; then
                            echo "$(boldblue ${name}) : $(green $(ps u --pid $procid | tail -n1 | awk '{for(i=1;i<13;i++) printf("\t%s",$i) }'))"
                        else
                            echo "$(yellow ${name}) : $(red $(ps u --pid $procid | tail -n1 | awk '{for(i=1;i<13;i++) printf("\t%s",$i) }'))"
                        fi
                    fi
                    num=$((num+1))
                done
            fi
        fi
    done

    # redis status
    if [[ $appname == "all" ]] || [[ $appname == "redis" ]] ; then
        ${TOOLSDIR}/redis.sh status 1 $REDIS_ARG
    fi

    case "$appname" in 
        om|all|influx*)
            sudo service influxdb status 2>&1 >> /dev/null
            if [ $? == 0 ]; then
                echo "$(boldblue influxdb) : $(green RUNNING)"
            else 
                echo "$(boldblue influxdb) : $(yellow Not running)"
            fi
            ;;
    esac
}

function getAppPid() {
    local name=$1
    local pid
    if [[ $name == "om" ]]; then
        pid="$(pgrep -f com.formationds.om.Main)"
    elif [[ $name == "am" ]]; then
        pid="$(pgrep bare_am)"
    elif [[  $name == "xdi"  ]]; then
        pid="$(pgrep -f com.formationds.am.Main)"
    else
        pid="$(pgrep ${apps[$name]})"
    fi
    if [[ $2 == "zombie" ]]; then
        echo -n $pid
    else
        for p in $pid; do
            if [[ "Z" != $(ps -o s= -p $p) ]]; then 
                echo -n "$p "
            fi
        done
    fi
}

function waitForAll() {
    local lpid=""
    local maxcount=20
    local count=0
    echo -n "... waiting for system to come up: "
    for name in $applist ; do
        lpid=""
        while [[ -z $lpid ]] && [[ $count -lt $maxcount ]] ; do
            echo -n "."
            lpid=$(getAppPid $name)
            if [[ -z $lpid ]]; then
                (( count++ ))
                sleep 1s ;
            fi
        done
    done
    echo
}

function waitForApp() {
    local name=$1
    local lpid=""
    local maxcount=20
    local waittime=1
    if [[ $# -ge 2 ]] ; then
        maxcount=$2
    fi

    if [[ $# -ge 3 ]] ; then
       waittime=$3
    fi

    local count=0
    echo -n "... waiting for [$(boldblue $name)] to come up: "
    lpid=""
    while [[ -z $lpid ]] && [[ $count -lt $maxcount ]] ; do
        echo -n "."
        lpid=$(getAppPid $name)
        if [[ -z $lpid ]]; then
            (( count++ ))
            sleep ${waittime}s ;
        fi
    done
    echo

    if [[ -z $lpid ]]; then
        return 1
    else
        return 0
    fi
}

function attachgdb() {
    local app=$1
    case "${app}" in
        om|am|dm|sm|pm|redis) ;;
    *)
        logerror "can attach gdb to only [om|am|dm|sm|pm|redis]"
        return
        ;;
    esac

    if (waitForApp $app 2000 0.1); then
        sudo gdb -p $(getAppPid $app)
    else
        logerror "could not attach to [$(blue $app)]"
    fi
}

function taillog() {
    local app=$1
    local logfiles
    case "${app}" in
        om|am|dm|sm|pm)
            ls -1 ${FDSROOT}/var/logs/${app}.log*.log
            for n in $(seq 0 20); do
                logfiles="$logfiles ${FDSROOT}/var/logs/${app}.log_${n}.log"
            done
            tail -qF ${logfiles} 2>/dev/null
            ;;
        redis)
            tail -F /fds/logs/redis/*.log
            ;;
        *)
            logerror "can tail logs of only om|am|dm|sm|pm|redis"
            ;;
    esac
}

function showerrors() {
    local apps="$@"
    if [[ $1 == 'all' ]]; then
        apps="am om dm sm pm xdi"
    fi
    for app in ${apps}; do
        loginfo $(yellow "showing errors/warn/critical log data for : ") $(blue $app)
        case "${app}" in
            om|am|dm|sm)
                grep -iE "\[(warning|error|CRITICAL)\]" ${FDSROOT}/var/logs/${app}.log*.log 2>/dev/null
                ;;
            pm)
                grep -iE "\[(warning|error|CRITICAL)\]" ${FDSROOT}/var/logs/platform.log*.log 2>/dev/null
                ;;
            xdi)
                grep -E " (WARN|ERROR|FATAL) " ${FDSROOT}/var/logs/om-xdi*.log ${FDSROOT}/var/logs/xdi*.log 2>/dev/null
                ;;
            *)
                logerror "can grep logs of only om|am|dm|sm|pm|xdi"
                ;;
        esac
        echo
    done
}

function showports() {
    local apps="$@"
    if [[ $1 == 'all' ]]; then
        apps="am om dm sm pm xdi"
    fi
    for app in ${apps}; do
        local pid=$(getAppPid $app)
        if [[ -n $pid ]]; then
            local pids=$(echo -en $pid| tr ' ' '|' | sed 's/.$//')
            loginfo "Ports used by : $(blue $app)/$pids"
            netstat -lntp | grep -E "PID|${pids}"
        fi
    done
}

function cleanBinDirs() {
    for node in bin node2 node3 node4; do
        bin_dir=${SOURCEDIR}/Build/linux-x86_64.${BUILDMODE}/${node}
        if [[ -d $bin_dir ]] ; then
            (
                cd ${bin_dir}
                loginfo "cleaning up: $(pwd)"

                rm -rf *.ldb 2>  /dev/null
                rm -rf logs stats 2> /dev/null
                rm -rf *SNode* 2> /dev/null
                rm -rf *ObjRankDB* 2> /dev/null
                rm om.*.log 2> /dev/null
                rm am.*.log 2> /dev/null
                rm sm.*.log 2> /dev/null
                rm -f ocache_stats.dat
                rm -f *.out
                rm -f core*
                rm -f Volume_* 2>/dev/null
            )
        fi
    done
}


function clean() {
    for node in ${FDSROOT} ${FDSROOT}/node1 ${FDSROOT}/node2 ${FDSROOT}/node3 ${FDSROOT}/node4 ; do
        if [[ -d $node ]] ; then
            loginfo "cleaning up: ${node}"
            (
                rm -rf /${node}/hdd/sd?
                rm -rf /${node}/ssd/sd?
                rm -rf /${node}/sys-repo/*
                rm -rf /${node}/user-repo/*
                rm -rf /${node}/dev/*
                rm -rf /${node}/var/stats/*
                rm -rf /${node}/var/db/*
                # redis stuff
                ${TOOLSDIR}/redis.sh clean 1 $REDIS_ARG

		rm -rf /${node}/var/logs/*.log*
		rm -rf /${node}/var/logs/*DLT
                #cleanlogs
            ) 2>/dev/null
        fi
    done

	rm -f /dev/shm/0x*

    cleanInfluxDB
    cleanBinDirs
}

function runTest() {
    local testname=$1
    local TESTSUITEDIR=${SOURCEDIR}/test/testsuites

    if [[ -n $testname ]] && [[ ${TESTS[$testname]+1} ]]; then
        stopApp all
        (cd ${TESTSUITEDIR}; ./ScenarioDriverSuite.py -q ${TESTS[$testname]})
    else
        logerror "no matching tests for [$testname]"
    fi
            
}

function cleanlogs() {
    (
        rm -f $(find /${FDSROOT}/var/ -type f | grep -v redis)
        rm -f $(find /${FDSROOT}/logs -type f | grep -v redis)
    ) 2>/dev/null
}

function source_lib() {
    export LD_LIBRARY_PATH=${FDSROOT}/lib:/usr/local/lib:/usr/lib/jvm/java-8-oracle/jre/lib/amd64;
    ulimit -c unlimited; ulimit -n 12800;
}

########################################################################
# Main Program
########################################################################

# parse input
# parse out the options & leave the rest is saved
args=( "$@" )
for ((n=0; n<$#; n++ ))
do
    opt=${args[$n]}
    case $opt in
        -f|--fds-root)
            (( n++ ))
            if [[ $n -ge $# ]]; then
                logerror "value expected for fdsroot"
                usage
            fi
            FDSROOT=${args[$n]}
            ;;
        -i|--from-install-dir)
            run_from_install_dir=1
            ;;
        -h|--help)
            usage
            ;;
        release)
            setBuildMode release
            exit 0
            ;;
        debug)
            setBuildMode debug
            exit 0
            ;;
        mode)
            printBuildMode
            exit 0
            ;;
        bindir)
            echo $BINDIR
            exit 0
            ;;
        testdir)
            echo $TESTDIR
            exit 0
            ;;
        *)
            if [[ -z $CMD ]] ; then CMD=$opt
            elif [[ -z $APP ]] ; then APP=$opt
            else
                logerror "unknown option [$opt] "
                usage
            fi
    esac
done

# else run from install dir
if [ $run_from_install_dir -eq 1 ]; then
    SOURCEDIR="$( cd ${TOOLSDIR}/../.. && pwd)"
    CONFIG_ETC=${SOURCEDIR}/etc
    BINDIR=${SOURCEDIR}/bin
    FDSROOT=${SOURCEDIR}
    REDIS_ARG=-i
    source_lib
fi


if [[ $CMD == "test" ]]; then
    TEST=$APP
    APP="all"
fi

# check the values
CMD=${CMD:="status"}
APP=${APP:="all"}
FDSROOT=${FDSROOT:=/fds}
TESTNAME=""



#echo "CMD=${CMD} APP=${APP} ROOT=${FDSROOT} SOURCEDIR=${SOURCEDIR} " \
#     "TOOLSDIR=${TOOLSDIR} CONFIG_ETC=${CONFIG_ETC} BINDIR=${BINDIR}"

#echo "args: ${args[@]}"
#exit 0

case "${CMD}" in
    kill|test|start|stop|restart|status|clean|clogs|cleanstart|startclean|gdb|tail|err*|port*) ;;
    *)
        logerror "unknown cmd [$CMD] "
        usage ;;
esac

case "${APP}" in
    om|am|dm|sm|pm|all|redis) ;;
    *)
        logerror "unknown app [$APP]"
        usage ;;
esac

printBuildMode

case "${CMD}" in
    start) startApp $APP
        [[ $APP == "all" ]] && waitForAll
        statusApp $APP
        ;;
    kill) stopApp  $APP;;
    stop) stopApp  $APP;;
    status) statusApp $APP;;
    clean)
        stopApp "all"
        clean
        ;;
    clogs) cleanlogs ;;
    restart)
            stopApp $APP
            startApp $APP
             waitForAll
            statusApp $APP
            ;;
    cleanstart|startclean)
        stopApp "all"
        clean
        startApp "all"
         waitForAll
        statusApp "all"
        ;;
    gdb)
        attachgdb $APP
        ;;
    tail)
        taillog $APP
        ;;
    err*)
        showerrors $APP
        ;;
    test)
        runTest $TEST
        ;;
    port*)
        showports $APP
        ;;
    *) usage ;;
esac
