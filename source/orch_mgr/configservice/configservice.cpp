// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <arpa/inet.h>

#include <apis/ConfigurationService.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <util/Log.h>
#include <OmResources.h>
#include <convert.h>
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::fds::apis;

namespace fds {
class OrchMgr;
}

class ConfigurationServiceHandler : virtual public ConfigurationServiceIf {
    fds::OrchMgr* om;
  public:
    ConfigurationServiceHandler(fds::OrchMgr* om) : om(om) {
    }

    // Don't do anything here. This stub is just to keep cpp compiler happy
    void createVolume(const std::string& domainName, const std::string& volumeName, const VolumePolicy& volumePolicy) {}
    void deleteVolume(const std::string& domainName, const std::string& volumeName) {}
    void statVolume(VolumeDescriptor& _return, const std::string& domainName, const std::string& volumeName) {}
    void listVolumes(std::vector<VolumeDescriptor> & _return, const std::string& domainName) {}

    void createVolume(boost::shared_ptr<std::string>& domainName, boost::shared_ptr<std::string>& volumeName, boost::shared_ptr<VolumePolicy>& volumePolicy) {

        LOGNOTIFY << " domain: " << domainName
                  << " volume: " << volumeName;

        Error err;
        OM_NodeDomainMod *domain = OM_NodeDomainMod::om_local_domain();
        OM_NodeContainer *local = OM_NodeDomainMod::om_loc_domain_ctrl();

        if (domain->om_local_domain_up()) {
            fpi::FDSP_MsgHdrTypePtr header;
            fpi::FDSP_CreateVolTypePtr request;
            convert::getFDSPCreateVolRequest(header, request, *domainName,*volumeName,*volumePolicy);
            err = local->om_create_vol(header, request, false);
        } else {
            LOGWARN << "OM Local Domain is not up yet .. try later";
        }
    }

    void deleteVolume(boost::shared_ptr<std::string>& domainName, boost::shared_ptr<std::string>& volumeName) {

        OM_NodeDomainMod *domain = OM_NodeDomainMod::om_local_domain();
        if (!domain->om_local_domain_up()) {
            LOGWARN << "OM Local Domain is not up yet .. try later";;
        }
        
        fpi::FDSP_MsgHdrTypePtr header;
        fpi::FDSP_DeleteVolTypePtr request;
        convert::getFDSPDeleteVolRequest(header, request,  *domainName,*volumeName);
        OM_NodeContainer *local = OM_NodeDomainMod::om_loc_domain_ctrl();
        fds::Error err = local->om_delete_vol(header, request);
    }

    void statVolume(VolumeDescriptor& _return, boost::shared_ptr<std::string>& domainName, boost::shared_ptr<std::string>& volumeName) {
    }

    void listVolumes(std::vector<VolumeDescriptor> & _return, boost::shared_ptr<std::string>& domainName) {

        OM_NodeContainer *local = OM_NodeDomainMod::om_loc_domain_ctrl();
        VolumeContainer::pointer vols = local->om_vol_mgr();

        vols->vol_up_foreach<std::vector<VolumeDescriptor> &>(_return, [] (std::vector<VolumeDescriptor> &vec ,fds::VolumeInfo::pointer vol) {
                VolumeDescriptor volDescriptor;
                volDescriptor.name = vol->vol_get_name();
                vec.push_back(volDescriptor);
            }
            );
    }

};

namespace fds {

std::thread* runConfigService(OrchMgr* om) {
    int port = 9090;
    boost::shared_ptr<ConfigurationServiceHandler> handler(new ConfigurationServiceHandler(om));
    boost::shared_ptr<TProcessor> processor(new ConfigurationServiceProcessor(handler));
    boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer* server=new TSimpleServer(processor, serverTransport, transportFactory, protocolFactory);
    std::thread* t = new std::thread ([=](){
            server->serve();
        });
    return t;
}

}  // namespace fds
